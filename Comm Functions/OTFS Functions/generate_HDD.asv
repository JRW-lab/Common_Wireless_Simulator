function H_DD = generate_HDD(obj,ambig_vals,ambig_t_range,ambig_f_range,L)

% Import settings from object
Fc = obj.Fc;
v_vel = obj.v_vel;
sbcar_spacing = obj.sbcar_spacing;
select_filter = obj.select_filter;
N_tsyms = obj.N_tsyms;
M_sbcars = obj.M_sbcars;
T = 1 / sbcar_spacing;

% Initialize and fill in block matrix
% render_range = zeros(N_tsyms, N_tsyms*M_sbcars);
% for i = 1:N_tsyms/2:N_tsyms*M_sbcars
%     render_range(i:i+N_tsyms-1, i:i+N_tsyms-1) = ones(N_tsyms);
% end
render_range = ones(N_tsyms*M_sbcars);

% Internal settings

% Create channel gain, delay and doppler shift values for each path
[chn_g,chn_tau,chn_v] = channel_generation(Fc,v_vel);

% Create each element of H_TF
H_TF = zeros(N_tsyms*M_sbcars);
for n1 = 0:N_tsyms-1
    for n2 = 0:N_tsyms-1
        % Compute time delay term
        time_diff = (n1 - n2) * T;
        time_diff_terms = time_diff - chn_tau;

        % Compute second exponential values
        exp_vals2 = exp(1j*2*pi*chn_v*n2*T);

        for m1 = 0:M_sbcars-1
            for m2 = 0:M_sbcars-1
                % Compute frequency delay term
                sbcar_diff = (m1 - m2) * sbcar_spacing;
                sbcar_diff_terms = sbcar_diff - chn_v;

                % Decide if element is within render scope
                if abs(m1-m2) <= L

                    % Compute ambiguity function values
                    xambig_vals = interp2( ...
                        ambig_f_range, ...   % Doppler/freq axis
                        ambig_t_range, ...   % Delay/time axis
                        ambig_vals, ...      % Ambiguity surface
                        sbcar_diff_terms, ...% Query freq (vector over paths)
                        time_diff_terms, ... % Query delay (vector over paths)
                        'linear', 0);        % Outside grid = 0

                    % Compute first exponential values
                    exp_vals1 = exp(1j.*2.*pi.*(chn_v + m2.*sbcar_spacing).*(time_diff_terms));

                    % Calculate h value
                    h = sum(chn_g .* xambig_vals .* exp_vals1 .* exp_vals2);

                    % Set h to be a value in H_TF
                    H_TF(m1*N_tsyms+n1+1,m2*N_tsyms+n2+1) = h;

                end
            end
        end
    end
end

[n1,n2,m1,m2] = ndgrid(0:N_tsyms-1, 0:N_tsyms-1, 0:M_sbcars-1, 0:M_sbcars-1);
time_diff = (n1 - n2) * T;       % size: N_tsyms x N_tsyms x M_sbcars x M_sbcars
sbcar_diff = (m1 - m2) * sbcar_spacing;
time_diff_terms = time_diff(:) - reshape(chn_tau, 1, []);   % flatten grid, keep paths
sbcar_diff_terms = sbcar_diff(:) - reshape(chn_v, 1, []);
xambig_vals = interp2(ambig_f_range, ambig_t_range, ambig_vals, ...
                      sbcar_diff_terms, time_diff_terms, 'linear', 0);
exp_vals1 = exp(1j * 2*pi * ((chn_v + m2(:)*sbcar_spacing) .* time_diff_terms));
exp_vals2 = exp(1j * 2*pi * chn_v .* (n2(:)*T));
h_vals = sum(chn_g .* xambig_vals .* exp_vals1 .* exp_vals2, 2); % sum over paths
H_TF = zeros(N_tsyms*M_sbcars);
for i = 1:M_sbcars
    for j = 1:M_sbcars

        indices = 1:N_tsyms^2;

        H_TF(1:N_tsyms,1:N_tsyms) = reshape(h_vals(indices), )

    end
end
H_TF2 = reshape(h_vals, [N_tsyms*M_sbcars, N_tsyms*M_sbcars]);

% Create DFT matrices and needed Kronecker product
F_N = generate_DFT(N_tsyms);
F_M = generate_DFT(M_sbcars);
F_cur = kron(F_M,F_N');

% Create final result
H_DD = F_cur' * H_TF * F_cur;